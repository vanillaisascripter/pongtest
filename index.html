<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3D Ping Pong</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      canvas {
        background: #111;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <script>
      const canvas = document.getElementById('game');
      const gl = canvas.getContext('webgl');

      if (!gl) {
        document.body.innerHTML = '<p>WebGL not supported on your device.</p>';
        throw new Error('WebGL not supported');
      }

      // Resize canvas to fit screen
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      window.addEventListener('resize', resize);
      resize();

      // Vertex shader
      const vsSource = `
        attribute vec4 aVertexPosition;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        void main() {
          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        }
      `;

      // Fragment shader
      const fsSource = `
        void main() {
          gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
      `;

      // Compile shader
      function compileShader(gl, source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          throw new Error('Shader compile error: ' + gl.getShaderInfoLog(shader));
        }
        return shader;
      }

      // Create program
      const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error('Program link error: ' + gl.getProgramInfoLog(program));
      }
      gl.useProgram(program);

      // Buffers
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

      // Table vertices
      const tableVertices = new Float32Array([
        -5, 0, -10,
         5, 0, -10,
         5, 0,  10,
        -5, 0,  10
      ]);
      gl.bufferData(gl.ARRAY_BUFFER, tableVertices, gl.STATIC_DRAW);

      // Ball vertices
      const ballVertices = new Float32Array([
        0, 0, 0
      ]);
      const ballBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, ballBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, ballVertices, gl.STATIC_DRAW);

      // Attributes and uniforms
      const positionAttributeLocation = gl.getAttribLocation(program, 'aVertexPosition');
      const projectionMatrixLocation = gl.getUniformLocation(program, 'uProjectionMatrix');
      const modelViewMatrixLocation = gl.getUniformLocation(program, 'uModelViewMatrix');

      // Game objects
      const ball = { x: 0, y: 0, z: 0, dx: 0.1, dy: 0.05, dz: 0.1 };

      // Touch controls
      let touches = [];
      canvas.addEventListener('touchstart', e => { touches = Array.from(e.touches); });
      canvas.addEventListener('touchmove', e => { touches = Array.from(e.touches); });
      canvas.addEventListener('touchend', e => { touches = Array.from(e.touches); });

      // Game loop
      function loop() {
        // Clear canvas
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Update ball
        ball.x += ball.dx;
        ball.y += ball.dy;
        ball.z += ball.dz;

        // Table collisions
        if (ball.y < 0 || ball.y > 2) ball.dy = -ball.dy;
        if (ball.x < -5 || ball.x > 5) ball.dx = -ball.dx;
        if (ball.z < -10 || ball.z > 10) ball.dz = -ball.dz;

        // Update projection and model view matrices
        const projectionMatrix = new Float32Array([
          2 / canvas.width, 0, 0, 0,
          0, 2 / canvas.height, 0, 0,
          0, 0, -2, 0,
          -1, -1, 0, 1
        ]);
        const modelViewMatrix = new Float32Array([
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          0, 0, 0, 1
        ]);

        gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);
        gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);

        // Draw table
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

        // Draw ball
        gl.bindBuffer(gl.ARRAY_BUFFER, ballBuffer);
        gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.drawArrays(gl.POINTS, 0, 1);

        requestAnimationFrame(loop);
      }
      loop();
    </script>
  </body>
</html>
